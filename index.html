<!DOCTYPE html>
<html>
  <head>
    <style>
      body, html{
        margin: 0;
        height: 100vh;
        background: linear-gradient(-45deg, #333, #000);
        overflow: hidden;
      }
      #c{
        border: 3px solid #fff3;
        position: absolute;
        background: #04f1;
        left: 50%;
        top: 50%;
        border-radius: 10px;
        transform: translate(-50%, -50%);
      }
    </style>
  </head>
  <body>
    <canvas id=c></canvas>
    <script>
      c = document.querySelector('#c')
      c.width = 1920
      c.height = 1080
      x = c.getContext('2d')
      C = Math.cos
      S = Math.sin
      t = 0
      T = Math.tan

      rsz = window.onresize = () =>{
        let b = document.body
        let margin = 10
        let n
        let d = .5625
        if(b.clientHeight/b.clientWidth > d){
          c.style.width = `${(n=b.clientWidth) - margin*2}px`
          c.style.height = `${n*d - margin*2}px`
        }else{
          c.style.height = `${(n=b.clientHeight) - margin*2}px`
          c.style.width = `${n/d - margin*2}px`
        }
      }

      rsz()

      async function Draw(){
        if(!t){
          fntstr = 'px Courier New'
          oX = oY = oZ = 0
          Rn = Math.random
          throwing = false
          R = (Rl,Pt,Yw,m) => {
            let p
            M = Math
            A = M.atan2
            H = M.hypot
            X = S(p=A(X,Z)+Yw) * (d=H(X,Z))
            Z = C(p)*d
            X = S(p=A(X,Y)+Rl) * (d=H(X,Y))
            Y = C(p) * d
            Y = S(p=A(Y,Z)+Pt) * (d=H(Y,Z))
            Z = C(p)*d
            if(m){
              X+=oX
              Y+=oY
              Z+=oZ
            }
          }
          
          Q = () => [c.width/2+X/Z*1400, c.height/2+Y/Z*1400]
          I=(A,B,M,D,E,F,G,H)=>(K=((G-E)*(B-F)-(H-F)*(A-E))/(J=(H-F)*(M-A)-(G-E)*(D-B)))>=0&&K<=1&&(L=((M-A)*(B-F)-(D-B)*(A-E))/J)>=0&&L<=1?[A+K*(M-A),B+K*(D-B)]:0
          
          Normal = (facet, autoFlipNormals=false, X1=0, Y1=0, Z1=0, flip_=false) => {
            let ax = 0, ay = 0, az = 0
            facet.map(q_=>{ ax += q_[0], ay += q_[1], az += q_[2] })
            ax /= facet.length, ay /= facet.length, az /= facet.length
            let b1 = facet[2][0]-facet[1][0], b2 = facet[2][1]-facet[1][1], b3 = facet[2][2]-facet[1][2]
            let c1 = facet[1][0]-facet[0][0], c2 = facet[1][1]-facet[0][1], c3 = facet[1][2]-facet[0][2]
            crs = [b2*c3-b3*c2,b3*c1-b1*c3,b1*c2-b2*c1]
            d = Math.hypot(...crs)+.001
            let nls = 1
            crs = crs.map(q=>q/d*nls)
            let X1_ = ax, Y1_ = ay, Z1_ = az
            let flip = 1
            if(autoFlipNormals){
              let d1_ = Math.hypot(X1_-X1,Y1_-Y1,Z1_-Z1)
              let d2_ = Math.hypot(X1-(ax + crs[0]/99),Y1-(ay + crs[1]/99),Z1-(az + crs[2]/99))
              flip = d2_>d1_?-1:1
            }
            if(flip_) flip *=-1
            let X2_ = ax + (crs[0]*=flip), Y2_ = ay + (crs[1]*=flip), Z2_ = az + (crs[2]*=flip)
            return [X1_, Y1_, Z1_, X2_, Y2_, Z2_]
          }

          reflect = (a, n) => {
            let d1 = Math.hypot(...a)+.0001
            let d2 = Math.hypot(...n)+.0001
            a[0]/=d1
            a[1]/=d1
            a[2]/=d1
            n[0]/=d2
            n[1]/=d2
            n[2]/=d2
            let dot = -a[0]*n[0] + -a[1]*n[1] + -a[2]*n[2]
            let rx = -a[0] - 2 * n[0] * dot
            let ry = -a[1] - 2 * n[1] * dot
            let rz = -a[2] - 2 * n[2] * dot
            return [-rx*d1, -ry*d1, -rz*d1]
          }

          bag_blue   = new Image()
          bag_blue.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABlJJREFUSEt9ls1vH0cZxz+zuzOzb7/9+T2OYztJY8dJSNOotKUqUhFR7/0T4MAZDpV6QALbIHFA4gBnDnDj2hMXiFRQ1aQoqRKCncR2nNhNbWzH9u9l97fvi3bjqBIS7GlGO7ufeZ5nvt95BN88HmAAfcAEKqAAxMn41cpXc32ybgC0T152/mtc1YsZP3/pp/NvvPnDlfX1wCqz9ajX3SiLPKzyol8VWWpIq8TSlWFqkeapabn+mKmcmUowYys9kwzCFkIIZUnKIsfxfGxDrD699derNWBq4tvfey6VIooipFQIxwXDIokHeFoTpSm4bYKRcQZ5SZKluG6LqiwYDELSJEZJiZUnxDtPCPwWgefvPrr5yUUhg+Ad7+zl21mW4/otcu1jj09jKZsiTwmzHC8YYZAmCOmQ5hm2bdPyAjpRRJ7FFFLjem3yvWfo3h523EMk4Webt25+UEcwOv7m+wdFWZJoH/Pst5DDpzG0h9Q2/cpAOx4ijUmiDllWg2w826UQBlmekZcFXjCGER5Sbf0L5/AZ6fON3+08vPeTGjA0+c6Nw25eCGvmCuXkPNbYNKa0EaaJYSniQR/fbRH2jppaRv1jhNKYpqQsC1p+m7TIUQjMr1YQ67fJt9eWD56sLNWAYPLt729H2g/SifPo89fJtI8hFVQVmBZVkaOlwjIVWZFhlAVJnpLnGVWR4QdjZEmEshTi+SrW5l2yzfvLB+svAeLU9fe+SIKJtwZDU4hz1/DGZ4niPoZhNVGYpoUrNf1B2OQ+qetRpIRxhHZ84qhLlado20NsPSDYWyN5cn957/GDBmCNzF/+vTyz8IOwPUU6+zp65DS20qR5TpomOK6HNCUmFcdhF88JSIoUsyhI8xRMSVVHm4QMxR2CjVscPry7vLf+EmAMXbjya4LRj4qpBeLZazjjM5hCkCCwpWzy7ipNkhVoJelFfeIyxyxK8nSAYUlMYVDGIe3oEPfpHaKNfy7vPr7fABiaufALe/rCzzrOCNncW1gj080JytIYaUk8txZq2Ui72WgSUVRVo4N00MWwNKIqMaMO3v4m+e4G1s6T5b1XgGB2bsmdXVhMR6bpBBMYY7PI1ihlnjIcjNINO01+XdOgn2WICsLeAcodagBVVWIJQbm/RTvtI/a3GKx9udx9+vBlBMH03JJ77tJiOXKaTusU5ul5srr6QqCcFmnYwQtGqYTAl4qoKEmSkMBrc3S836Qo6x5QdPdplwXqYJPByu1vABMXry4Vo9OLZjBGNHyGYuIclbSpxae8NsIwm5o0p6QB19syCMPjRnhSOWTpgLz3AnNng6HoBcnqrV8eP1v7ebN08uK1Jffc5cWBdOk6w4ipeXJpU1YVlu1TaY3CpOX6JFmGliZREjfFj+s5ZbOZwcFX6K8fYX79CHG485vjjZWPG8DE3NWl4YXri309RKc1QTU1B4aCMkOZFqWlUMqhH/cZ9gKKSjSCq41OSYWyLOLaSva30Y8+x+v9m/Ro54+Ha6s/egm4eHVJT55b7OuAcuE9Yu0hpMZ2WiR1/m2HSjlo5dKLuviOR5QmFGVOVRSUZY6rPaLddcTtT9BphBTc2bv3+dsNYGzuypIcm1os3SGK1z8g9UeRbot+Zx9hSqRhopSmNGVjF0WekNSmZ1pQFk1R6nvAqo/v3/+E1TvAcezu7j8+nXkJeO3KkjU6uYhpUl5+n/jUayjHbwRlmFZj21U6wA3GmuJ6rk+/f4TtBJS1NgQUZUW29xTryz+T72/TCoaq3S9ujjSA05fe+K0aP/PjpC6c06KanCc0FUZ7AukPYVZl4zu1HVjabWyEIidOBvjtMTIEZdQh31qhWP0M1fiXyf7dv43VAPv8uzf+UinnuzWgvp0spZsLxlAuVnscf+QUfWERl1XzcR2NYwjCzgs8o8KsKvIsJTnea45zFPaR0iJ8tvqdGtBauPHh427Yn+x2jnA9n+LE5KTS2LYDUjHAQnttbKXoHu3DoI+rJVG/i9Y2FaJRdHMzui5ZmrJ359MzjW7OvnvjQVJyeRDWOTdEmiaN7WipeknY2zbKajtLwq08Tl4oxy7KvKigFGVRGMKUSlimb5iW57aCC7kh567MzXXX7t39w/7mw181NThpTf5X6+GctC/J/2lh6jan/lfd5viNM0JY//g/fUoTBY5tRKAAAAAASUVORK5CYII='
          bag_orange = new Image()
          
          bag_orange.src = 'data:image/png;base64,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'
          
          bags = [ bag_blue, bag_orange ]

          burst = new Image()
          burst.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAaCAYAAACpSkzOAAAAAXNSR0IArs4c6QAAA/RJREFUSEu9lltrHGUYx39znsnuZNOaA6ltSiW0JUFEb2xAEQS96F2/g1/Cj+Cn8CP0UqEXCkppoXeSxBaaKsFEtyZ2D9md88jz7r6b180u0RsHHmaXfWd++3/OFv/TZV3GqUGfmXe2lndYoO7zrrmgMcCEyOfp8/JybcKo5wHngSwDZAPaZoEqQEyA6j4LNgukIfJyZ2zy2R0DzWdKwDQNraZhF0D1+b+XF4t5yiI8avVd4CN3WRQMyWFiBSCmgCZsAppylQYERIQK4/ghVRZQuR6WiM5LbDJKhgo3JAHSMfQCzASJe+S7hoSELLDgx7hVC9tpQR1j1YHKLMvKqMo+pdWhsDsMsx4JA2AIZGOXiipRN8oiQ424RVwlShpEfgvfXsGr1nGta7j2Kra1qEBV3aegTV4fk3NMVr1mmL0hoW8ok/gpF5ogHXABLbBIizBaIeAmQX2bhrNFZG3i28sqQhmnnBUvGbJPUr0gK34hKdr06IBSJqrEhaUJ0ukrEJ+IJqF/hdC6ToMtGu6HXHV22AjWuebJWfgtrzhM25xWT+mUTxlWe6TpISknDJUqiZkGiSrlOhMk4Y9peisE1i1i5wOWnc+4Hb3HJ4su26ujpNr9E77vljxP9jgtHnFWPmNQH3CWt0noGbHSGYiuGx2fiBaLON4aC84mS/YOa959Poo3eLBpc/crqHPY/xIevqr5sXdEO/+WbvWYtHhOUvxBd+I+SX0dp4kiE9QicNdouJs07Huse/f5uLXBgzs2d78euX/vC3j4ouaH7jG/F9/Qrx4zvADS2aeSwewEEqOIJWJCbxXPfYcm77Pifc5W9C6frrps3xj1zZ9ewXenJbvJPifFI3r5MwbOAeWwTYfuVJpPss6M0Si1Q/8qDesGTXeL2LrHsrvDrXCV64Eoh8Ok4iA/4XX+hG71hLTYpZceknAyjpEUryjS/W9SRzq9fZXeMS1iV1TdpOneock2obNJZL2lmk9SnzKoDuiVuwyqn8mKX+kXbfq8Gae3gFSHkKKdV7ChUrXoL+HaUkvrBM7buKxh0xp3uh4pbbLyiEF9pAo2yf8yCtbsDiPXTaW4uEZUhSzRIPBj7GpJtaDAjqGOVEWUZOR1j6zsUFgd6lxyTdePLtbJ2JjVVAX0z6baYIHCiwjcACeX3yxKryAtUpw84YwBiepxOi7zm6rR83RinI+JBj4VHj4utRoTgqpIKUjUiBAFelzo+TR7TBguFJXmVNUzSA9B7QXpeKoYx3fVbmbNokn3nl4opmaTBgvo34zyC9N1LmhqdOilxFxUzI3HXFD+83IyETljGzK8fH5s/C/mrlyX7nWGW6VVXbgu2+f0A38DSpS5KuPCd64AAAAASUVORK5CYII="

          starImgs = Array(9).fill().map(v=>({img: new Image(), loaded: false}))
          starImgs[0].img.src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAAAAXNSR0IArs4c6QAAAjtJREFUSEu9lsGK2kAcxsdMNtUutmBbB9OcvAhW8ZCD6AO40mdoDx4EsfR9Sj1YX0Eo9g0EFckhXoIXIUQ0dGEpdu2m6ZZPMrIVdhOzNgMDEjPzm+/7fzOTGIm4xSLmkccAMfb22AWHBWIc+p8ogQIhxI0KSD2Fv6MCioQQKLyJCih5wO3/BiIogizLTxzHEWzbvvaSGjg8QVPKU4naCdlsNp5IJOhsNtt4SQUQ3XebBAWiXlRRFJExJqVSqfNkMiksFosfy+XSsSwL4UFifVMbBIh3RFmWzxRFSeRyuWeqqr6UJIlOJpO1rutXpmleW5blEEIAflBlECBsFFVVjefz+VSz2cxXq9ULKB4Oh9+63e5sOp1eapqGenKl92bpLpD/5vXa2cgYo5lMBurOa7Xa63a7/Y5S+hEzuq77qdPpdAeDganr+ma73XJ7eT15mPaqDxVy2C6NXiJpOp2WAKzX60qr1XpPKf3gAT/3er0v/X7fnM/nm/V6fWPbNlTeDRFgvAc6vPeWlkqlF41G402lUnmLxYzH46+wdDQafQ9j6X2+76zloSkUCs/L5fIr13VjmqbZhmFcGYbx0wsNUvrgngwSGiwEUCRV5PbioWmaOxtPvS0w976mgBeLxaeU0lvPRl6vk258bjeUxhhjcTxYrVY4S/8Jhd/ZGtTSw3kABOiXH+Dw/7DAM28inC5HtbBA3IdQ6Ht2nkohaokW+Fri4LAK+Tjf6+hUCkN9IvL9dVTRH/tyWEtDc/8CVG3QHb4cnU0AAAAASUVORK5CYII="
          
          starImgs[4].img.src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABEpJREFUSEuVlm1MG3Ucxz/30N6VtpSWjsmEMYTExUVfbNOZRTOSGfeQKWHIFOJeuLdKsvjKxPhSXxoS9e3cXAJGMhQne4gubpoYp9urOTMNBhgUlG48tNC7Xu+u5q6UXjsQ1+TS9K79fn6/////+34r8BCvE2+d2HLq41PTD/EThA2+LHqft7/92qPDH36e8NzLA8617ms9gFdYoK1QyEv7uxrPXxmcdNWuusJecXstSiXA+Vy410YBMrvy3oRwZG/P1m9+6r/LBHkC5AmTrwA9APECiuKFih3hJgS2IxIpQNtbu7YNjw6Ou+BxbP4hzyz2CqgoXgbxAgoVO5U74geQ2IKIjUgNIn6E51sO7fjxr4u3SWMjYZPEdkG/YFOHzVUegBQBD4pHkKhHIoyPIBIg7Wo+3HZz+sL3ZLBIY7FIjiwWt7EqIKv7412WUuWOeBMyEfyo+FEUBdnnf3bzkc6fp0cGyeUMDN1Aw2AegxSmC7mFxU23CwfgduMAStUHkNjjVu5jEwphRz4URIlVIdqhA3Udr19ODp8mZ2bQ0861zAI6k2TRsPgC07NUbhdFgMAuRJ5E4mlkQijEUAmFwwSqa/BVxZEDse74Kz0DyYFPsY0URmYWbXmRudQyOjrTGG4X45jevSgAvBvbjI8GVAJqFdW1NSj+OpTYY08Fd+7trenY98H8Z9+OpX+7iplOkE4lMeYXuY/Gn+iueMUyCbu62+JyUJNkVZb0VmSjRa/SY3YdVeEGVYk2hpTaxpi8ubk32vHc/tDO6tMLl6cGlq78msrdG1vO3rub1RYnpYyeqE4o98REzrD/UE1Fs6ys6bfjpmKXd3AMmRgyTQQIKSHUaIxgTaOo1D7+TvSN4z2R/S3vJc9c+zI18hXG3BiaPoOemOc+GZJojGLxA6Z3o0t78ASSe/YfQaYZlagawB+JEFTjqNEWxGD0zWj3q5/Mnz1LbmmWXHqSzNIcS3MpV3yMrGeJrBXbWOnAOU3FTd7hDpifWlQUJYgaq8bnjyD6wu2bOo8Pzw6dwTJT6MsLaKk0up7hb3RmyHEdyz1NnoErn4PiMXWWKY6fMAohJYBYE0DyK/vqX+y+lrzQj5nVWc5kWNJ1LLL8jsEiFpex1jqmTjfOLJR3oSC5EAUf1fgQVHl3/cHDN6YujYBuomOQJccYObfqNaovDloRUPKhZxDZhojTUQMyAhIq4p7Gg7uvT1664dqEjUUG0/UjR9wxvdIUl1lF0cZLE51GoA7RdVLH8KoQsBBfaO1s+e7WuVE08gTJM43NHewKcUdv1VEr86AcoiG4lr0ZgShC5/bupnN3BiaYJ+9atZMLBRf1hs+6dl3eiTd0nI40hJePdW39+vzghPtFJ2wKyVYUXDM+14vMUrKVclA4+m5Pw9D7/VNr5PCacend5I1y2y3kUO/RLRc/Gir+q9gw8P8vYBV+8uTJ+r6+vpn/qqby2b+dv8odlLV6kAAAAABJRU5ErkJggg=="
          
          lineFaceI = (X1, Y1, Z1, X2, Y2, Z2, facet, autoFlipNormals=false, showNormals=false) => {
            let X_, Y_, Z_, d, m, l_,K,J,L,p
            let R_ = (Rl,Pt,Yw,m)=>{
              let M=Math, A=M.atan2, H=M.hypot
              X_=S(p=A(X_,Y_)+Rl)*(d=H(X_,Y_)),Y_=C(p)*d,X_=S(p=A(X_,Z_)+Yw)*(d=H(X_,Z_)),Z_=C(p)*d,Y_=S(p=A(Y_,Z_)+Pt)*(d=H(Y_,Z_)),Z_=C(p)*d
              if(m){ X_+=oX,Y_+=oY,Z_+=oZ }
            }
            let rotSwitch = m =>{
              switch(m){
                case 0: R_(0,0,Math.PI/2); break
                case 1: R_(0,Math.PI/2,0); break
                case 2: R_(Math.PI/2,0,Math.PI/2); break
              }        
            }
            let ax = 0, ay = 0, az = 0
            facet.map(q_=>{ ax += q_[0], ay += q_[1], az += q_[2] })
            ax /= facet.length, ay /= facet.length, az /= facet.length
            let b1 = facet[2][0]-facet[1][0], b2 = facet[2][1]-facet[1][1], b3 = facet[2][2]-facet[1][2]
            let c1 = facet[1][0]-facet[0][0], c2 = facet[1][1]-facet[0][1], c3 = facet[1][2]-facet[0][2]
            let crs = [b2*c3-b3*c2,b3*c1-b1*c3,b1*c2-b2*c1]
            d = Math.hypot(...crs)+.001
            let nls = 1 //normal line length
            crs = crs.map(q=>q/d*nls)
            let X1_ = ax, Y1_ = ay, Z1_ = az
            let flip = 1
            if(autoFlipNormals){
              let d1_ = Math.hypot(X1_-X1,Y1_-Y1,Z1_-Z1)
              let d2_ = Math.hypot(X1-(ax + crs[0]/99),Y1-(ay + crs[1]/99),Z1-(az + crs[2]/99))
              flip = d2_>d1_?-1:1
            }
            let X2_ = ax + (crs[0]*=flip), Y2_ = ay + (crs[1]*=flip), Z2_ = az + (crs[2]*=flip)
            let p1_ = Math.atan2(X2_-X1_,Z2_-Z1_)
            let p2_ = -(Math.acos((Y2_-Y1_)/(Math.hypot(X2_-X1_,Y2_-Y1_,Z2_-Z1_)+.001))+Math.PI/2)
            let isc = false, iscs = [false,false,false]
            X_ = X1, Y_ = Y1, Z_ = Z1
            R_(0,-p2_,-p1_)
            let rx_ = X_, ry_ = Y_, rz_ = Z_
            for(let m=3;m--;){
              if(isc === false){
                X_ = rx_, Y_ = ry_, Z_ = rz_
                rotSwitch(m)
                X1_ = X_, Y1_ = Y_, Z1_ = Z_ = 5, X_ = X2, Y_ = Y2, Z_ = Z2
                R_(0,-p2_,-p1_)
                rotSwitch(m)
                X2_ = X_, Y2_ = Y_, Z2_ = Z_
                facet.map((q_,j_)=>{
                  if(isc === false){
                    let l = j_
                    X_ = facet[l][0], Y_ = facet[l][1], Z_ = facet[l][2]
                    R_(0,-p2_,-p1_)
                    rotSwitch(m)
                    let X3_=X_, Y3_=Y_, Z3_=Z_
                    l = (j_+1)%facet.length
                    X_ = facet[l][0], Y_ = facet[l][1], Z_ = facet[l][2]
                    R_(0,-p2_,-p1_)
                    rotSwitch(m)
                    let X4_ = X_, Y4_ = Y_, Z4_ = Z_
                    if(l_=I(X1_,Y1_,X2_,Y2_,X3_,Y3_,X4_,Y4_)) iscs[m] = l_
                  }
                })
              }
            }
            if(iscs.filter(v=>v!==false).length==3){
              let iscx = iscs[1][0], iscy = iscs[0][1], iscz = iscs[0][0]
              let pointInPoly = true
              ax=0, ay=0, az=0
              facet.map((q_, j_)=>{ ax+=q_[0], ay+=q_[1], az+=q_[2] })
              ax/=facet.length, ay/=facet.length, az/=facet.length
              X_ = ax, Y_ = ay, Z_ = az
              R_(0,-p2_,-p1_)
              X1_ = X_, Y1_ = Y_, Z1_ = Z_
              X2_ = iscx, Y2_ = iscy, Z2_ = iscz
              facet.map((q_,j_)=>{
                if(pointInPoly){
                  let l = j_
                  X_ = facet[l][0], Y_ = facet[l][1], Z_ = facet[l][2]
                  R_(0,-p2_,-p1_)
                  let X3_ = X_, Y3_ = Y_, Z3_ = Z_
                  l = (j_+1)%facet.length
                  X_ = facet[l][0], Y_ = facet[l][1], Z_ = facet[l][2]
                  R_(0,-p2_,-p1_)
                  let X4_ = X_, Y4_ = Y_, Z4_ = Z_
                  if(I(X1_,Y1_,X2_,Y2_,X3_,Y3_,X4_,Y4_)) pointInPoly = false
                }
              })
              if(pointInPoly){
                X_ = iscx, Y_ = iscy, Z_ = iscz
                R_(0,p2_,0)
                R_(0,0,p1_)
                isc = [[X_,Y_,Z_], [crs[0],crs[1],crs[2]]]
              }
            }
            return isc
          }

          Cube = size => {
            for(CB=[],j=6;j--;CB=[...CB,b])for(b=[],i=4;i--;)b=[...b,[(a=[S(p=Math.PI*2/4*i+Math.PI/4),C(p),2**.5/2])[j%3]*(l=j<3?size/2**.5:-size/2**.5),a[(j+1)%3]*l,a[(j+2)%3]*l]]
            return CB
          }

          Octahedron = size => {
            ret = []
            let h = size/1.25
            for(j=8;j--;){
              a = []
              X = 0
              Y = 0
              Z = h * (j<4?-1:1)
              a = [...a, [X,Y,Z]]
              X = S(p=Math.PI*2/4*j) * size/1.25
              Y = C(p) * size/1.25
              Z = 0
              a = [...a, [X,Y,Z]]
              X = S(p=Math.PI*2/4*(j+1)) * size/1.25
              Y = C(p) * size/1.25
              Z = 0
              a = [...a, [X,Y,Z]]
              ret = [...ret, a]
            }
            return ret      
          }

          subbed = (subs, size, sphereize, shape) => {
            for(let m=subs; m--;){
              base = shape
              shape = []
              base.map(v=>{
                l = 0
                X1 = v[l][0]
                Y1 = v[l][1]
                Z1 = v[l][2]
                l = 1
                X2 = v[l][0]
                Y2 = v[l][1]
                Z2 = v[l][2]
                l = 2
                X3 = v[l][0]
                Y3 = v[l][1]
                Z3 = v[l][2]
                if(v.length > 3){
                  l = 3
                  X4 = v[l][0]
                  Y4 = v[l][1]
                  Z4 = v[l][2]
                  if(v.length > 4){
                    l = 4
                    X5 = v[l][0]
                    Y5 = v[l][1]
                    Z5 = v[l][2]
                  }
                }
                mx1 = (X1+X2)/2
                my1 = (Y1+Y2)/2
                mz1 = (Z1+Z2)/2
                mx2 = (X2+X3)/2
                my2 = (Y2+Y3)/2
                mz2 = (Z2+Z3)/2
                a = []
                switch(v.length){
                  case 3:
                    mx3 = (X3+X1)/2
                    my3 = (Y3+Y1)/2
                    mz3 = (Z3+Z1)/2
                    X = X1, Y = Y1, Z = Z1, a = [...a, [X,Y,Z]]
                    X = mx1, Y = my1, Z = mz1, a = [...a, [X,Y,Z]]
                    X = mx3, Y = my3, Z = mz3, a = [...a, [X,Y,Z]]
                    shape = [...shape, a]
                    a = []
                    X = mx1, Y = my1, Z = mz1, a = [...a, [X,Y,Z]]
                    X = X2, Y = Y2, Z = Z2, a = [...a, [X,Y,Z]]
                    X = mx2, Y = my2, Z = mz2, a = [...a, [X,Y,Z]]
                    shape = [...shape, a]
                    a = []
                    X = mx3, Y = my3, Z = mz3, a = [...a, [X,Y,Z]]
                    X = mx2, Y = my2, Z = mz2, a = [...a, [X,Y,Z]]
                    X = X3, Y = Y3, Z = Z3, a = [...a, [X,Y,Z]]
                    shape = [...shape, a]
                    a = []
                    X = mx1, Y = my1, Z = mz1, a = [...a, [X,Y,Z]]
                    X = mx2, Y = my2, Z = mz2, a = [...a, [X,Y,Z]]
                    X = mx3, Y = my3, Z = mz3, a = [...a, [X,Y,Z]]
                    shape = [...shape, a]
                    break
                  case 4:
                    mx3 = (X3+X4)/2
                    my3 = (Y3+Y4)/2
                    mz3 = (Z3+Z4)/2
                    mx4 = (X4+X1)/2
                    my4 = (Y4+Y1)/2
                    mz4 = (Z4+Z1)/2
                    cx = (X1+X2+X3+X4)/4
                    cy = (Y1+Y2+Y3+Y4)/4
                    cz = (Z1+Z2+Z3+Z4)/4
                    X = X1, Y = Y1, Z = Z1, a = [...a, [X,Y,Z]]
                    X = mx1, Y = my1, Z = mz1, a = [...a, [X,Y,Z]]
                    X = cx, Y = cy, Z = cz, a = [...a, [X,Y,Z]]
                    X = mx4, Y = my4, Z = mz4, a = [...a, [X,Y,Z]]
                    shape = [...shape, a]
                    a = []
                    X = mx1, Y = my1, Z = mz1, a = [...a, [X,Y,Z]]
                    X = X2, Y = Y2, Z = Z2, a = [...a, [X,Y,Z]]
                    X = mx2, Y = my2, Z = mz2, a = [...a, [X,Y,Z]]
                    X = cx, Y = cy, Z = cz, a = [...a, [X,Y,Z]]
                    shape = [...shape, a]
                    a = []
                    X = cx, Y = cy, Z = cz, a = [...a, [X,Y,Z]]
                    X = mx2, Y = my2, Z = mz2, a = [...a, [X,Y,Z]]
                    X = X3, Y = Y3, Z = Z3, a = [...a, [X,Y,Z]]
                    X = mx3, Y = my3, Z = mz3, a = [...a, [X,Y,Z]]
                    shape = [...shape, a]
                    a = []
                    X = mx4, Y = my4, Z = mz4, a = [...a, [X,Y,Z]]
                    X = cx, Y = cy, Z = cz, a = [...a, [X,Y,Z]]
                    X = mx3, Y = my3, Z = mz3, a = [...a, [X,Y,Z]]
                    X = X4, Y = Y4, Z = Z4, a = [...a, [X,Y,Z]]
                    shape = [...shape, a]
                    break
                  case 5:
                    cx = (X1+X2+X3+X4+X5)/5
                    cy = (Y1+Y2+Y3+Y4+Y5)/5
                    cz = (Z1+Z2+Z3+Z4+Z5)/5
                    mx3 = (X3+X4)/2
                    my3 = (Y3+Y4)/2
                    mz3 = (Z3+Z4)/2
                    mx4 = (X4+X5)/2
                    my4 = (Y4+Y5)/2
                    mz4 = (Z4+Z5)/2
                    mx5 = (X5+X1)/2
                    my5 = (Y5+Y1)/2
                    mz5 = (Z5+Z1)/2
                    X = X1, Y = Y1, Z = Z1, a = [...a, [X,Y,Z]]
                    X = X2, Y = Y2, Z = Z2, a = [...a, [X,Y,Z]]
                    X = cx, Y = cy, Z = cz, a = [...a, [X,Y,Z]]
                    shape = [...shape, a]
                    a = []
                    X = X2, Y = Y2, Z = Z2, a = [...a, [X,Y,Z]]
                    X = X3, Y = Y3, Z = Z3, a = [...a, [X,Y,Z]]
                    X = cx, Y = cy, Z = cz, a = [...a, [X,Y,Z]]
                    shape = [...shape, a]
                    a = []
                    X = X3, Y = Y3, Z = Z3, a = [...a, [X,Y,Z]]
                    X = X4, Y = Y4, Z = Z4, a = [...a, [X,Y,Z]]
                    X = cx, Y = cy, Z = cz, a = [...a, [X,Y,Z]]
                    shape = [...shape, a]
                    a = []
                    X = X4, Y = Y4, Z = Z4, a = [...a, [X,Y,Z]]
                    X = X5, Y = Y5, Z = Z5, a = [...a, [X,Y,Z]]
                    X = cx, Y = cy, Z = cz, a = [...a, [X,Y,Z]]
                    shape = [...shape, a]
                    a = []
                    X = X5, Y = Y5, Z = Z5, a = [...a, [X,Y,Z]]
                    X = X1, Y = Y1, Z = Z1, a = [...a, [X,Y,Z]]
                    X = cx, Y = cy, Z = cz, a = [...a, [X,Y,Z]]
                    shape = [...shape, a]
                    a = []
                    break
                }
              })
            }
            if(sphereize){
              ip1 = sphereize
              ip2 = 1-sphereize
              shape = shape.map(v=>{
                v = v.map(q=>{
                  X = q[0]
                  Y = q[1]
                  Z = q[2]
                  d = Math.hypot(X,Y,Z)
                  X /= d
                  Y /= d
                  Z /= d
                  X *= size/2*ip1 + d*ip2
                  Y *= size/2*ip1 + d*ip2
                  Z *= size/2*ip1 + d*ip2
                  return [X,Y,Z]
                })
                return v
              })
            }
            return shape
          }

          subDividedOctahedron   = (size, subs, sphereize = 0) => subbed(subs, size, sphereize, Octahedron(size))
          subDividedCube         = (size, subs, sphereize = 0) => subbed(subs, size, sphereize, Cube(size))

          stroke = (scol, fcol, lw, dl, oga=1, ocp=true) => {
            if(scol){
              x.strokeStyle = scol
              if(ocp) x.closePath()
              x.lineWidth = Math.min(20, 50/Z*lw)
              if(dl){
                x.globalAlpha = .25 * oga
                x.stroke()
                x.lineWidth/=2
              }
              x.globalAlpha = 1*oga
              x.stroke()
            }
            if(fcol){
              x.globalAlpha = 1*oga
              x.fillStyle = fcol
              x.fill()
            }
          }
          
          box = subDividedCube(5,0,0).map(v => {
            v.map(q => {
              X = q[0]
              Y = q[1]
              Z = q[2]
              if(X>0){
                Y *= .5
              }else{
                Y *= 3/12/2
              }
              Y = Math.min(0, Y)
              R(0, 0, -Math.PI/2)
              R(0,Math.PI,Math.PI)
              Y-=.33
              R(0,-.1875,0)
              X *= .5
              q[0] = X
              q[1] = Y
              q[2] = Z
              q[3] = 0
            })
            return v
          })
          a = []
          sd = 16
          ls = .5 * (2**.5/2)
          for(i=sd;i--;){
            X = S(p=Math.PI*2/sd*i) * ls + ls*4
            Y = 0
            Z = C(p) * ls
            R(0, 0, -Math.PI/2)
            R(0,Math.PI,Math.PI)
              Y-=.33
              R(0,-.1875,0)
            a = [...a, [X,Y,Z,1]]
          }
          
          box = [...box, a]
          ax=az=0
          maxy = -1e6
          ct = 0
          box.map(v=>{
            v.map(q=>{
              if(!q[3]){
                ax += q[0]
                az += q[2]
                ct++
                if(q[1] > maxy) maxy = q[1]
              }
            })
          })
          ax /= ct
          az /= ct
          box.map(v=>{
            v.map(q=>{
              q[0] -= ax
              q[1] -= maxy
              q[2] -= az
            })
          })
          
          a = []
          box[6].map((v, i) => {
            l1 = i
            l2 = (i+1)%box[6].length
            X = box[6][l1][0]
            Y = box[6][l1][1]
            Z = box[6][l1][2]
            a = [...a, [X,Y,Z,1]]
            X = box[6][l1][0]
            Y = -.1
            Z = box[6][l1][2]
            a = [...a, [X,Y,Z,1]]
            X = box[6][l2][0]
            Y = -.1
            Z = box[6][l2][2]
            a = [...a, [X,Y,Z,1]]
            X = box[6][l2][0]
            Y = box[6][l2][1]
            Z = box[6][l2][2]
            a = [...a, [X,Y,Z,1]]
          })
          box = [...box, a]
          
          boxen = [
            [0, 0, 54*ls, structuredClone(box)],
            [0, 0, -54*ls, structuredClone(box).map(v=>{
              v.map(q=>{
                X = q[0]
                Y = q[1]
                Z = q[2]
                R(0,0,Math.PI)
                q[0] = X
                q[1] = Y
                q[2] = Z
              })
              return v
            })],
          ]
          
          cl = 56
          rw = 56
          sp = 2**.5/1.5
          grid = []
          Array(cl*rw).fill().map((v, i) => {
            tx = ((i%cl)-cl/2 + .5) * sp
            ty = 0
            tz = ((i/cl|0)-rw/2 + .5) * sp
            a= []
            for(j=4; j--;){
              X = tx + S(p=Math.PI*2/4*j + Math.PI/4)/1.5
              Y = ty + 0
              Z = tz + C(p) /1.5
              a = [...a, [X, Y, Z]]
            }
            grid = [...grid, a]
          })
          
          window.onkeydown = e => {
            idleTimer = t+10
            if(keyTimers[e.keyCode] <= t){
              keys[e.keyCode] = true
              keyTimers[e.keyCode] = t + keyTimerInterval
            }
          }
          
          window.onkeyup = e => {
            keys[e.keyCode] = false
          }
          
          doKeys = () => {
            keys.map((v, i) => {
              if(v){
                if(!gameInPlay && i != 32) return
                switch(i){
                  case 32:
                    init()
                  break
                  case 83:
                    skyMode++
                    skyMode%=skyModes.length
                    keys[i] = false
                  break
                }
              }
            })
          }
          
          newBags = () => {
            return Array(4).fill().map(v=>{
              return {
                ofx: 0, ofy: 0,
                omx: -1, omy: -1,
                X:0, Y:0, Z:0,
                vx:0, vy:0, vz:0,
                thrown: false, vel: 0,
                velbuf: Array(10).fill().map(v=>[0,0,0]),
                settled: false,
                inTheHole: false,
                onTop: false,
                bounced: false
              }
            })
          }
          
          init = () => {
            victor            = -1
            gameInPlay        = true
            AIthrowPending    = false
            mx                = 0
            my                = 0
            sideView          = false
            playerSwapPending = false
            grav              = .008
            inning            = 0
            idleTimer         = t+10
            skyMode           = 1
            skyModes          = [
              'day',
              'night'
            ]
            throwing          = false
            keys              = Array(128).fill(false)
            keyTimers         = Array(128).fill(0)
            keyTimerInterval  = .2
            players           = [
              {
                bags: newBags(),
                name: 'human',
                score: 0,
                pending: 0,
              },
              {
                bags: newBags(),
                name: 'ai',
                score: 0,
                pending: 0,
              },
            ]
            playerAtThrow     = 0
          }

          c.onmousemove = e => {
            if(!gameInPlay || playerAtThrow) return
            idleTimer = t + 10
            rect = c.getBoundingClientRect()
            mx = (e.pageX-rect.left)/rect.width*c.width
            my = (e.pageY-rect.top)/rect.height*c.height
          }
          
          doVictory = val => {
            gameInPlay = false
            victor = val
          }
          
          throwBag = bag => {
            
            throwing = true
            bag.thrown = true
            l = bag.velbuf.filter(v=>v[0])
            let vel = 0
            let vx  = 0
            let vy  = 0
            l.map(v=>{
              vel += v[0]
              vx  += v[1]
              vy  += v[2]
            })
            vel /= l.length
            vx /= l.length
            vy /= l.length
            p = Math.atan2(vx, vy)
            let v = vel / 500
            bag.X = 0
            bag.Y = -3
            bag.Z = -20 * (playerAtThrow ? -1 : 1)
            bag.vx = vx / 500 * (playerAtThrow ? -1 : 1)
            bag.vy = -.3
            bag.vz = (.36 + v) * (playerAtThrow ? -1 : 1)
            ozv = 40
            sideView = Rn() < .5
          }
          
          mb = false
          c.onmousedown = e => {
            if(!gameInPlay) return
            if(!playerAtThrow){
              mb = true
            }else{
              mb = false
            }
          }
         
          c.onmouseup = e => {
            if(!gameInPlay) return
            if(playerAtThrow) return
            mb = false
            rect = c.getBoundingClientRect()
            mx = (e.pageX-rect.left)/rect.width*c.width
            my = (e.pageY-rect.top)/rect.height*c.height
            players.map((player, pidx) => {
              player.bags.map((bag, bidx) => {
                bag.omx = bag.omy = -1
                if(bag.vel > 20) throwBag(bag)
                bag.vel = 0
                bag.velbuf = Array(10).fill().map(v=>[0,0,0])
              })
            })
          }
         
          init()
          rlv = rlv_ = 0, ptv = 0
          ywv = ywv_ = oyw = tyw = 0
          ozv = 40
          oyv = 0
          
          bounding = subDividedOctahedron(100, 4, 1).map(v=>{
            v.map(q=>{
              q[1] = Math.min(1, q[1])
            })
            return v
          })
          
          floor = (bag, bidx_) => {
            X1      = bag.X
            Y1      = -10
            Z1      = bag.Z
            X2      = bag.X
            Y2      = 10
            Z2      = bag.Z
            let ret = false
            boxen.map((box, bidx) => {
              if(bidx == playerAtThrow){
                tx_ = box[0]
                ty_ = box[1]
                tz_ = box[2]
                box[3].map((v, i) =>{
                  if(i == 4){
                    if((l=lineFaceI(X1,Y1,Z1,X2,Y2,Z2,structuredClone(v).map(q=>{
                      q[0] += tx_
                      q[1] += ty_
                      q[2] += tz_
                      return q
                    })))){
                      ret = l[0][1]
                    }
                  }
                  if(ret && i == 6){
                    ax = ay = az = 0
                    v.map(q=>{
                      ax += q[0]
                      ay += q[1]
                      az += q[2]
                    })
                    ax /= v.length
                    ay /= v.length
                    az /= v.length
                    ax += tx_
                    ay += ty_
                    az += tz_
                    d = Math.hypot(ax - bag.X, ay - bag.Y, az - bag.Z)
                    if(d < 2**.5/2.5 && (l=lineFaceI(X1,Y1,Z1,X2,Y2,Z2,structuredClone(v).map(q => {
                      q[0] += tx_
                      q[1] += ty_
                      q[2] += tz_
                      return q
                    })))){
                      players[playerAtThrow].bags[bidx_].settled = true
                      players[playerAtThrow].bags[bidx_].inTheHole = true
                      if(!players[playerAtThrow].bags[bidx_].bounced){
                        players[playerAtThrow].pending += 3
                      }
                      players[playerAtThrow].bags[bidx_].vx = bag.vy = bag.vz = 0
                      fx = players[playerAtThrow].bags[bidx_].X = ax
                      fy = players[playerAtThrow].bags[bidx_].Y = -.2
                      fz = players[playerAtThrow].bags[bidx_].Z = az
                      spawnFlash(fx, fy, fz)
                      ret = false
                    }
                  }
                })
              }
            })
            return ret === false ? 0 : ret
          }
          
          flashes = []
          spawnFlash = (X,Y,Z) => {
            flashes = [...flashes, [X,Y,Z,1]]
          }
        }

        x.globalAlpha = 1
        x.fillStyle   = `#0008`
        x.fillRect(0,0,c.width,c.height)
        
        rlv_ += (Rn()-.5)/500
        rlv_ /= 1.02
        rlv += rlv_
        rlv /= 1.02
        
        ywv_ += (Rn()-.5)/2500
        ywv_ /= 1.05
        ywv += ywv_
        ywv /= 1.02
        
        ptv += ((throwing ? -.66 : -.2) - ptv) / 50
        
        ozv += ((throwing ? (sideView || playerAtThrow ? 40 : 10) : 38 + (mb || playerAtThrow? 0 : 6)) - ozv) / 20
        oyv += ((throwing && !playerAtThrow ? 10 : 0) - oyv) / 40
        
        tyw += ((throwing ? (playerAtThrow ? Math.PI : 0) + (sideView ? Math.PI/2 : 0) : ywv + oyw + (playerAtThrow ? Math.PI : 0)) - tyw) / 20
        
        if(mb || playerAtThrow){
          oyw /=1.25
        }else{
          if(!playerAtThrow) oyw = idleTimer <=t ? (t/8%Math.PI*2) : 0
        }
        
        x.lineJoin    = x.lineCap = 'round'
        if(throwing){
          oX  = 0
          oY  = oyv
          oZ  = ozv
          Rl  = 0
          Pt  = ptv
          Yw  = tyw
        }else{
          oX  = 0
          oY  = oyv
          oZ  = ozv
          Rl  = rlv
          Pt  = ptv
          Yw  = tyw
        }
        
        doKeys()

        bounding.map(v=>{
          x.beginPath()
          n = Normal(v, true)
          v.map(q=>{
            X = q[0]
            Y = q[1]
            Z = q[2]
            R(Rl,Pt,Yw,1)
            if(Z>0) x.lineTo(...Q())
          })
          col1 = ''//'#fff1'
          d1 = Math.hypot(n[0],n[1],n[2])
          switch(skyModes[skyMode]){
            case 'day':
              topCol = `hsla(${-150+Math.min(20, n[1]**2/10)},99%, ${65+n[1]}%, 1)`
              bottomCol = `hsla(${50+d1**2/20},99%, 32%, .5)`
            break
            case 'night':
              topCol = `hsla(${230+Math.min(20, n[1]**2/5)},99%, ${5-n[1]}%, 1)`
              bottomCol = `hsla(${130+50+d1**1.5/5},99%, 40%, .5)`
            break
          }
          col2 = n[1] > n[4] ? bottomCol : topCol
          stroke(col1, col2, 1, false)
        })
        
        grid.map((v, i) => {
          ax=ay=az=0
          v.map(q=>{
            ax+=q[0]
            ay+=q[1]
            az+=q[2]
          })
          ax/=v.length
          ay/=v.length
          az/=v.length
          if((d_=Math.hypot(ax*3.5, az)) < cl*sp/2){
            
            x.beginPath()
            v.map(q => {
              X = q[0]
              Y = q[1]
              Z = q[2]
              R(Rl,Pt,Yw,1)
              if(Z>0) x.lineTo(...Q())
            })
            col1 = ''
            col2 = (i+((i/cl|0)%2))%2 ? '#301' : '#000'
            oga = 1 / (1+(1+d_**16)/3e21)
            stroke(col1, col2, 1, true, oga)
          }
        })
        
        forSort = []
        
        boxen.map((box, idx) => {
          tx = box[0]
          ty = box[1]
          tz = box[2]
          box[3].map((v, i) => {
            ax = ay = az = 0
            v.map(q=>{
              ax += q[0]
              ay += q[1]
              az += q[2]
            })
            X = ax /= v.length
            Y = ay /= v.length
            Z = az /= v.length
            R(Rl,Pt,Yw,1)
            if(Z>0){
              Z_ = Z
              tp = false
              a = []
              n = Normal(structuredClone(v).map(q=>{
                q[0]+=tx
                q[1]+=ty
                q[2]+=tz
                return q
              }), true, tx, ty-.25, tz, true)
              X = n[0]
              Y = n[1]
              Z = n[2]
              R(Rl,Pt,Yw,1)
              nx1 = X
              ny1 = Y
              nz1 = Z
              X = n[3]
              Y = n[4]
              Z = n[5]
              R(Rl,Pt,Yw,1)
              nx2 = X
              ny2 = Y
              nz2 = Z
              x.beginPath()
              v.map(q=>{
                X = q[0]+tx
                Y = q[1]+ty
                Z = q[2]+tz
                if(q[3]) tp = true
                R(Rl,Pt,Yw,1)
                if(Z>0) a = [...a, Q()]
              })
              if(nz2 < nz1){
                col1 = '#000a'
                col2 = tp ? '#000' : (idx ? '#f804' : '#08f4')
                if(!tp) forSort = [...forSort, [Z_, a, col1, col2]]
              }
            }
          })
        })
        
        forSort.sort((a, b) => (b[0]-a[0])).map(v=>{
          x.beginPath()
          v[1].map(q=>x.lineTo(...q))
          Z = v[0]
          stroke(v[2], v[3], 5, false)
        })

        boxen.map((box, idx) => {
          tx = box[0]
          ty = box[1]
          tz = box[2]
          box[3].map((v, i) => {
            if(i<7){
              tp = false
              a = []
              x.beginPath()
              v.map(q=>{
                X = q[0]+tx
                Y = q[1]+ty
                Z = q[2]+tz
                if(q[3]) tp = true
                R(Rl,Pt,Yw,1)
                if(Z>0) x.lineTo(...Q())
              })
              if(tp){
                col1 = '#000a'
                col2 = '#000'
                stroke(col1, col2, 1, true)
              }
            }
          })
        })

        
        pl = players[playerAtThrow]
        
        if(throwing){
          if(gameInPlay){
            let res = true
            pl.bags.map((bag, bidx) => {
              if(bag.thrown){
                if((d = Math.hypot(bag.vx, bag.vy, bag.vz)) > .01) res = false
              }
            })
            if(res) {
              pl.bags.map((bag, bidx) => {
                if(!bag.settled && bag.thrown){
                  if((fl = floor(bag, bidx)) !== false){
                    bag.Y = fl - .2
                    bag.vx = bag.vy = bag.vz = 0
                    bag.settled = true
                  }
                }
              })
              if(!playerAtThrow) {
                throwing = false
              }else{
                if(!AIthrowPending){
                  AIthrowPending = true
                  setTimeout(() => {
                    AIthrowPending = false
                    throwing = false
                    idleTimer = t + 10
                  }, 3000)
                }
              }
            }
          }
        }else{
          if(pl.bags.filter(bag=>bag.thrown).length == 4){
            if(!playerSwapPending){
              playerSwapPending = true
              setTimeout(()=>{
                
                pl.bags = newBags()
                playerAtThrow++
                playerAtThrow%=2
                if(!playerAtThrow){
                  players[0].score += Math.max(0, players[0].pending - players[1].pending)
                  players[1].score += Math.max(0, players[1].pending - players[0].pending)
                  players[0].pending = players[1].pending = 0
                  if(players[0].score >= 21){
                    doVictory(0)
                  }else if(players[1].score >= 21){
                    doVictory(1)
                  }else{
                    inning++
                  }
                }
                playerSwapPending = false
              },1000)
            }
          }
        }
        
        pl.bags.map((bag, bidx) => {
          if(bag.thrown){
            if(!bag.settled && bag.Y + bag.vy > (fl = floor(bag, bidx))){
              if(fl !== false){
                bag.Y = fl - bag.vy
                bag.vx *= .25
                bag.vy *= -.15
                bag.vz *= .25
                bag.vy -= grav
                if(fl === 0 && !bag.settled) bag.bounced = true
              }
            }
            if(bag.settled){
              if(!bag.inTheHole && !bag.onTop && bag.Y < -.25){
                bag.onTop = true
                if(!bag.bounced){
                  players[playerAtThrow].pending += 1
                }
              }
              X = bag.X
              Y = bag.Y
              Z = bag.Z
            }else{
              for(m=3;m--;) {
                x.beginPath()
                for(i=2;i--;){
                  X = 0
                  Y = 0
                  Z = (-1 + i + .5)*20
                  R(0,0,Math.PI/4 + Math.PI/3*m + t/4)
                  X += bag.X
                  Z += bag.Z
                  R(Rl,Pt,Yw,1)
                  if(Z>0) x.lineTo(...Q())
                }
                stroke('#4f26','',5, true)
              }
              x.beginPath()
              for(i=2;i--;){
                X = bag.X
                Y = i?0:bag.Y
                Z = bag.Z
                R(Rl,Pt,Yw,1)
                if(Z>0) x.lineTo(...Q())
              }
              stroke('#4f2a','',6, true)
              
              X = bag.X += bag.vx
              Y = bag.Y += bag.vy += grav
              Z = bag.Z += bag.vz
            }
            R(Rl, Pt, Yw, 1)
            if(Z>0){
              l = Q()
              s = Math.min(1e4, 1e3/Z * (throwing ? 1 : 1)) * (bag.inTheHole ? 6 : 2)
              x.drawImage(burst, l[0]-s/2, l[1]-s/2, s, s)
              s/=(bag.inTheHole ? 6 : 2)
              x.drawImage(bags[playerAtThrow], l[0]-s/2, l[1]-s/2, s, s)
            }        
          }else{
            tx = X = 25.5
            ty = Y = bidx*4 - 13
            tz = Z = - (mb || playerAtThrow ? 0 : (throwing? 1 : 6))
            Z = 42
            if(Z>0){
              l = Q()
              s = Math.min(1e4, 5e3/Z) * 3
              x.drawImage(burst, l[0]-s/2 + bag.ofx, l[1]-s/2+bag.ofy, s, s)
              s/=3
              x.drawImage(bags[playerAtThrow], l[0]-s/2 + bag.ofx, l[1]-s/2+bag.ofy, s, s)
              x.beginPath()
              a = []
              for(j=4;j--;){
                X = tx + S(p=Math.PI*2/4*j+Math.PI/4)*2.5
                Y = ty + C(p)*2.5
                Z = tz
                Z = 42
                //R(0,0,0,1)
                if(Z>0) {
                  l = Q()
                  a = [...a, [l[0] + bag.ofx, l[1]+bag.ofy]]
                  x.lineTo(l[0] + bag.ofx, l[1]+bag.ofy)
                }
              }
              ax = ay = 0
              a.map((v, i) => {
                ax += v[0]
                ay += v[1]
              })
              ax /= a.length
              ay /= a.length
            }
            hover = true
            a.map((v, i) => {
              if(hover){
                l1 = i
                l2 = (i+1)%a.length
                X1 = a[l1][0]
                Y1 = a[l1][1]
                X2 = a[l2][0]
                Y2 = a[l2][1]
                X3 = ax
                Y3 = ay
                X4 = mx
                Y4 = my
                if(I(X1,Y1,X2,Y2,X3,Y3,X4,Y4)) hover = false
              }
            })
            ct = 0
            players.map(player=>{
              player.bags.map(bag=>{
                if(bag.omx !== -1) ct++
              })
            })
            if(ct<1 && hover || bag.omx != -1){
              col1 = '#0f2'
              col2 = ''
              stroke(col1, col2, 10, true)
              if(mb || playerAtThrow){
                if(bag.omx != -1){
                  bag.ofx += mx - bag.omx
                  bag.ofy += my - bag.omy
                  bag.velbuf = [[Math.hypot(mx-bag.omx, my-bag.omy), mx - bag.omx, my - bag.omy], ...bag.velbuf]
                  while(bag.velbuf.length>10) bag.velbuf.pop()
                  l = bag.velbuf.filter(v=>v[0])
                  let vel = 0
                  l.map(v=>vel += v[0])
                  bag.vel = vel /= l.length
                }
                bag.omx = mx
                bag.omy = my
              }
            }
          }
        })

        boxen.map((box, idx) => {
          tx = box[0]
          ty = box[1]
          tz = box[2]
          box[3].map((v, i) => {
            if(i>=7){
              tp = false
              a = []
              x.beginPath()
              v.map(q=>{
                X = q[0]+tx
                Y = q[1]+ty
                Z = q[2]+tz
                if(q[3]) tp = true
                R(Rl,Pt,Yw,1)
                if(Z>0) x.lineTo(...Q())
              })
              if(tp){
                col1 = '#000a'
                col2 = '#000'
                stroke(col1, col2, .5, false)
              }
            }
          })
        })
        
        flashes = flashes.filter(v=>v[3]>0)
        flashes.map(v=>{
          X = v[0]
          Y = v[1]
          Z = v[2]
          R(Rl,Pt,Yw,1)
          if(Z>0){
            l = Q()
            s = Math.min(1e4, 4e4*v[3]/Z)
            x.drawImage(starImgs[4].img, l[0]-s/2/1.06, l[1]-s/2/1.02, s, s)
            s*=1.5
            x.drawImage(starImgs[0].img, l[0]-s/2, l[1]-s/2, s, s)
          }
          v[3] -= .025
        })
        
        if(!throwing || playerAtThrow){
          fs = 32
          
          x.fillStyle = '#333'
          x.fillRect(0, 0, c.width/3.5, fs*1.5)
          x.font = fs+fntstr
          x.fillStyle = '#fff'
          x.strokeStyle = '#0008'
          x.lineWidth = 10
          x.textAlign = 'left'
          x.strokeText(`score    player    pending`, 20, fs/1.1)
          x.fillText(`score    player    pending`, 20, fs/1.1)
          
          x.fillStyle = '#102'
          x.textAlign = 'center'
          x.fillRect(c.width/3.5 + 20, 0, c.width/3.5, fs*1.5)
          x.strokeText(`first to 21 wins`, c.width/3.5 * 1.5, fs/1.1)
          x.fillStyle = '#fff'
          x.fillText(`first to 21 wins`, c.width/3.5 * 1.5, fs/1.1)
          
          x.fillStyle = '#222'
          x.textAlign = 'left'
          x.fillRect(c.width/3.5*2 + 40, 0, c.width/3.5 + 20, fs*1.5)
          x.strokeText(`rules: each inning, one`, c.width/3.5 * 2 + 60, fs/1.1)
          x.fillStyle = '#fff'
          x.fillText(`rules: each inning, one`, c.width/3.5 * 2 + 60, fs/1.1)
          
          players.map((pl, idx_) => {
            idx = idx_+1
            x.fillStyle = idx_ ? '#f80b' : '#08fb'
            x.fillRect(0, fs*1.5*idx, c.width/3.5, fs*1.5)
            x.font = fs+fntstr
            x.fillStyle = '#fff'
            x.strokeStyle = '#0008'
            x.lineWidth = 10
            x.textAlign = 'left'
            x.strokeText(`  ${pl.score}      ${pl.name}`, 20, fs/1.1+fs*1.5*idx)
            x.strokeText(`                      ${pl.pending}`, 20, fs/1.1+fs*1.5*idx)
            x.fillText(`  ${pl.score}      ${pl.name}`, 20, fs/1.1+fs*1.5*idx)
            x.fillText(`                      ${pl.pending}`, 20, fs/1.1+fs*1.5*idx)

            x.fillStyle = idx_ ? '#0f8b' : '#40fb'
            x.fillRect(c.width/3.5 + 20, fs*1.5*idx, c.width/3.5, fs*1.5)
            x.font = fs+fntstr
            x.fillStyle = '#fff'
            x.strokeStyle = '#0008'
            x.lineWidth = 10
            x.textAlign = 'left'

            x.fillStyle = idx_ ? '#444b' : '#40fb'
            x.fillRect(c.width/3.5*2 + 40, fs*1.5*idx, c.width/3.5, fs*1.5)
            x.font = fs+fntstr
            x.fillStyle = '#fff'
            x.strokeStyle = '#0008'
            x.lineWidth = 10
            x.textAlign = 'left'
            
            if(idx_){
              x.strokeText(`  ${inning}         ${playerAtThrow%2?'bottom':'top'}`, c.width/3.5 + 20, fs/1.1+fs*1.5*idx)
              x.fillText(`  ${inning}         ${playerAtThrow%2?'bottom':'top'}`, c.width/3.5 + 20, fs/1.1+fs*1.5*idx)
            }else{
              x.strokeText(`inning     half `, c.width/3.5 + 40, fs/1.1+fs*1.5*idx)
              x.fillText(`inning     half `, c.width/3.5 + 40, fs/1.1+fs*1.5*idx)
            }
            
            x.fillStyle = idx_ ? '#222' : '#333'
            x.fillRect(c.width/3.5*2 + 40, fs*1.5*idx, c.width/3.5 + 20, fs*1.5)
            x.font = fs+fntstr
            x.fillStyle = '#fff'
            x.strokeStyle = '#0008'
            x.lineWidth = 10
            x.textAlign = 'left'
            if(idx_){
              x.strokeText(`may cancel existing points`, c.width/3.5*2 + 60, fs/1.1+fs*1.5*idx)
              x.fillText(`may cancel existing points`, c.width/3.5*2 + 60, fs/1.1+fs*1.5*idx)
            }else{
              x.strokeText(`player may score. 2nd player`, c.width/3.5 * 2 + 60, fs/1.1+fs*1.5*idx)
              x.fillText(`player may score. 2nd player`, c.width/3.5 * 2 + 60, fs/1.1+fs*1.5*idx)
            }
          })
        
          if(!playerAtThrow){
            x.font = (fs = 64)+fntstr
            x.fillStyle = '#0f44'
            x.strokeStyle = '#0008'
            x.lineWidth = 10
            x.fillRect(c.width/2-400, c.height - 100, 800, 90)
            x.strokeRect(c.width/2-400, c.height - 100, 800, 90)
            x.fillStyle = '#fff'
            x.textAlign = 'center'
            x.strokeText(`your throw drunkie!`, c.width/2, c.height - fs/1.66)
            x.fillText(`your throw drunkie!`, c.width/2, c.height - fs/1.66)
          }else{
            x.font = (fs = 64)+fntstr
            x.fillStyle = '#ff04'
            x.strokeStyle = '#0008'
            x.lineWidth = 10
            x.fillRect(c.width/2-400, c.height - 100, 800, 90)
            x.strokeRect(c.width/2-400, c.height - 100, 800, 90)
            x.fillStyle = '#fff'
            x.textAlign = 'center'
            x.strokeText(`CPU is throwing...`, c.width/2, c.height - fs/1.66)
            x.fillText(`CPU is throwing...`, c.width/2, c.height - fs/1.66)
          }
        }
        
        if(playerAtThrow){ // do AI
          if(players[1].bags.filter(bag=>!bag.thrown).length && !throwing){
            throwing = true
            setTimeout(()=>{
              let bag = players[1].bags.filter(bag=>!bag.thrown)[0]
              for(m=10;m--;){
                AIvariance = 30
                bag.velbuf = [[Rn()*AIvariance*4, (Rn()-.5)*AIvariance*2, (Rn()-.5)*AIvariance*2], ...bag.velbuf]
                while(bag.velbuf.length>10) bag.velbuf.pop()
                l = bag.velbuf.filter(v=>v[0])
                let vel = 0
                l.map(v=>vel += v[0])
                bag.vel = vel /= l.length
              }
              throwBag(bag)
            }, 1000)
          }
        }
        
        if(!gameInPlay){
          x.fillStyle = victor ? '#f002' : '#0f42'
          x.fillRect(0,0,c.width,c.height)
          x.font = (fs = 64) + fntstr
          x.fillStyle = '#000'
          x.strokeStyle = '#fff'
          x.lineWidth = 10
          x.textAlign = 'center'
          x.strokeText(`victory -> ${players[victor].name}`, c.width/2, c.height/2-fs)
          x.fillText(`victory -> ${players[victor].name}`, c.width/2, c.height/2-fs)
          x.strokeText(`hit the space key`, c.width/2, c.height/2-fs + fs * 2)
          x.fillText(`hit the space key`, c.width/2, c.height/2-fs + fs * 2)
        }
        
        t+=1/60
        requestAnimationFrame(Draw)
      }
      Draw()
    </script>
  </body>
</html>